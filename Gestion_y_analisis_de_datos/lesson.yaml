- Class: meta
  Course: ConoceR
  Lesson: Gestion_y_analisis_de_datos
  Author: David H. Duncan (based on Will Morris & John Baumgartner)
  Type: Standard
  Organization: Universidad Técnica Particular de Loja
  Version: 2.3.1

- Class: text
  Output: "¡Hola buenas! En esta lección, aprenderá crear objetos de datos 
  de varias fuentes, y como sacar estadísticos de resumen rápidamente. ¿List@?"

- Class: text
  Output: "Antes de empezar, confirma que Ud esté en su proyecto de RStudio.
  Arriba, a la derecha, verá una caja de azul claro y a su lado debe aparecer
  el nombre de su proyecto. Si ve (none), significa que no esta en el proyecto
  y Ud debería abrirlo del menu <<File>> antes de continuar."
  
- Class: cmd_question
  Output: "Luego, teclea 'getwd()' (de <<get wORKING dIRECTORY>>) en la consola 
  para confirmar de otra manera en donde esté trabajando."
  CorrectAnswer: getwd()
  AnswerTests: omnitest(correctExpr='getwd()')
  Hint: "Por favor escriba 'getwd()' y pulse Intro." 

- Class: text
  Output: "En realidad, la decisión de establecer un espacio de proyecto en
  RStudio es uno de las mas importantes para facilitar el manejo de sus datos
  y archivos muchos."

- Class: text
  Output: "La dirección que sale 
  en la consola al teclear getwd() debe corresponder con la dirección que se ve 
  por encima de la ventanilla FILES. ¿Todo bien? Adelante, pues."

- Class: text
  Output: "Muchas veces, la primera cosa que querramos hacer es introducir un
  conjunto de datos que están almacenados en un archivo digital. Por lo tanto, 
  empezamos en esta lección ampliando las opciones que hay."

- Class: mult_question
  Output: "En lecciones y vídeos pasados usted hubiera visto comandos para la
  importación de datos al entorno de R.  "
  AnswerChoices: "*.csv (valores seperados por comas); *.kmz (keyhole markup language); Microsoft Access base de datos"
  CorrectAnswer: *.csv (valores seperados por comas)
  AnswerTests: omnitest(correctVal="*.csv (valores seperados por comas)")
  Hint: "De este listado, usted solo hubiera visto comandos para leer datos
  almacenados en el formato csv - valores seperados por comas - en este curso." 

- Class: text
  Output: "También, usted puede utilizar la función `read.table()` para leer 
  datos que ya están en formato de filas y columnas, incluso archivos tipo csv. 
  La diferencia es en los ajustes, las cual se ha ajustado al tipo csv para la
  función read.csv(). De hecho, read.csv usa read.table en el fondo.
  R puede ubicar el archivo con su ruta de archivo, o bien, si el archivo 
  está ubicado en su carpeta de trabajo, podemos llamarlo directamente así."

- Class: cmd_question
  Output: "Vamos a leer unos datos alamacenados en formato csv mediante el comando  
  read.table("ciclovia.csv", header=TRUE, sep=',', na.strings='NA'). Dese la
  oportunidad ahora mismo."
  CorrectAnswer: read.table("", header=TRUE, sep=',', na.strings='NA')
  AnswerTests: omnitest(correctExpr= "read.table('ciclovia.csv', header=TRUE, sep=',', na.strings='NA')")
  Hint: "Escriba el comando precisamente como aparece arriba. Aunque puede ser
  tedioso, cada argumento a la función tiene su propósito para lograr que los 
  datos aterricen salvos y sanos para el análisis en R."
  
- Class: text
  Output: "¿Qué paso? Si ejecutamos la orden así, R lo hace, y por defecto 
  imprime los resultados. Ya lo supo, ¿no? Ha acabado de pasarle un monton de datos rapidísimo, lo
  cual significa que R entendiera el comando, pero no retiene nada vigente
  en memoría de lo que salió.  Tiene que darlo un nombre, ¿verdad?
  
- Class: cmd_question
  Output: "Cuando querremos conservar datos para trabajarlos, necesitamos 
  atribuirlo un nombre con '<-' para que R lo asigne una ubicación en el entorno
  de trabajo y se acordará que el objeto está. Vamos a llamarle a este conjunto
  'cicLoja' porque son datos acerca del proyecto de la ciclovia de Loja.  Ahora, 
  Recupere el comando con read.csv pero esta vez ponga el nombre y el símbolo 
  de asignación delante de él."
  CorrectAnswer: cicLoja <- read.table('ciclovia.csv', header=TRUE, sep=',',
  na.strings='NA')

- Class: text
  Output: "De mi opinión, la idea con esta lección es enseñarle lo mínimo
  posible de un par de opciones, así que no pienso en explicar en detalle cada
  argumento que usted hubiera teclead en el último paso. En breve, después del
  nombre y dirección del archivo, llevó un argumento 'header =' que pregunta si 
  los datos vienen encabezados (TRUE) o no (FALSE)..." 

- Class: text
  Output: "Luego, 'sep=' pregunta por 
  la caracter que sepera los valores del archivo. Ya que nuestro datos son
  separados por comas (.csv) informamos a R de este hecho de forma muy directa 
  ','. El último argumento na.strings = quiere saber como sabrá cuando encuentre
  a valores perdidos.  Va a suponer que celdas vacías si estén en esa clase, 
  pero algunos autores suelen ingresar un valor especial para señalar valores
  perdidos, como un número fuera del rango de lo posible para la variable."
  
- Class: text
  Output: "Acabo de comentar que mucha gente suele ingresar un valor especial 
  para señalar valores perdidos. ¿Qué sería la ventaja de esa práctica versus,
  la opción de dejar la celda vacía? Esto sería un buen temito para el foro me 
  parece. ¡Es una cuestión sencilla pero algo existencial!"

- Class: mult_question
  Output: "Volviéndonos al tema de los archivos de datos separados por comas, 
  tal vez usted acabara de darse cuenta de un inconveniente sencillo pero 
  importante con el 
  formato debido a diferencias en las costumbres de notación númerica entre el 
  inglés y el castellano.  ¿Cuál de los siguientes podría ser el inconveniente?"
  AnswerChoices: "El estánder para indicar decimales en castellano es con la coma; CSV en castellano sería VCS; En castellano los números son más grandes"
  CorrectAnswer: El estánder para indicar decimales en castellano es con la coma
  AnswerTests: omnitest(correcVal="El estánder para indicar decimales en castellano es con la coma")
  Hint: "Demasiado fácil, ¿no? Un inconveniente podría ser que mientras que en 
  muchos paises y idiomas se indica decimales con el punto, en castellano se los
  señala con la coma. En realidad, todo depende de los adjustes de su computadora
  y programas demás que intervenieran en el proceso. He visto problemas en 
  algunas ocasiones y que todo funciona sin problema en otras. Lo importante es 
  que usted esté consciente de la posibilidad." 

- Class: cmd_question
  Output: "Pues, ¿Funcionó ese mando? Podemos revisar el encabezado de la tabla,
  las primeras seis filas utilizando la función head(). Siempre vale la pena
  echar un vistazo a una muestra del conjunto."
  CorrectAnswer: head(cicLoja)
  AnswerTests: omnitest(correctExpr= 'head(cicLoja)')
  Hint: "En los parentesis de la función, escriba el nombre de su objeto no más, 
  así head(cicLoja)."
  
- Class: text
  Output: "Insisto, la función 'read.csv()' es más sencilla que 'read.table()',
  pero exige que los datos sean formateados de una manera especifica. Una vez 
  entendido este formato, mucha gente eligirá 'read.csv()'. En este caso, la
  llamada hubiera sido cicLoja <- read.csv("ciclovia.csv")."

- Class: text
  Output: "Mientras que tecleara el comando con read.table hubiera ojeado los
  muchos argumentos que acepta la función read.table( ) aparte de los que usted
  ejecutó. Basta mencionar acá que brinda un nivel de control en todos los 
  ajustes que quizas le sirva algún día."

- Class: cmd_question
  Output: "Un momento de práctica antes de continuar, tenemos un objeto de datos,
  debemos arrojar una gráfica o resumen de algún tipo. Eche un vistazo a las
  variables con str(cicLoja) ya mismo."
  CorrectAnswer: str(cicLoja)
  AnswerTests: omnitest(correctExpr= "str(cicLoja)")
  Hint: "Teclee el comando precisamente como aparece al fin del diálogo para 
  continuar."


Etc, etc. Sin embargo, hemos descubrido que para alguna razón, no funciona. Así que, podemos guardar una version del conjunto de datos como un archivo `.csv` en lugar de leerlos directamente. Abandonamos al  Excel!  Pero, ahora se ve como se puede descubrir paquetes can puedan servirnos en tareas especificas.

```{r read_leafWater3}
rn_leafWaterPot <- read.csv('rn_leafWaterPot.csv')
```

Hechamos un vistazo a los datos...
```{r head_leafWater, eval=FALSE}
head(rn_leafWaterPot)                                                 
```
Ahora sabemos como leer un conjunto de datos en R. Hay muchas 
más opciones pero esta es uno de las más usado.
#####################################3

4. Interrogar unos datos
-----------------------------------------------------------------------------

Vamos a jugar con otro conjunto de datos. En este caso son datos estáan incluidos en R, así que no necesitamos utilizar `read.table()` o `read.csv()`. El conjunto se llama `swiss` y resume indicadores de fertilidad y estatus socio-economico de las provincias francoparlantes de Suiza (del año 1888). Todos los numeros son porcentajes de población.

Asignamos otro nombre al conjunto, para proceder por el camino tipico de editar o analizar los datos.
```{r read_seedln}
suiza <- swiss                     
```

La función `head` mostra las primeras filas de un objeto, en este caso un `data.frame`. Mostra seis filas por defecto pero se puede escoger otro número por especificar el argumento `n=`.
```{r head_seedln, eval=FALSE}
head(suiza)                                                  
```

Por el otro lado, `tail` nos muestra las últimas seis filas por defecto.
```{r tail_seedln, eval=FALSE}
tail(suiza)                                                   
```

Este tipo de objeto se llama `data.frame`, verdad?
```{r class_seedln}
class(suiza)
```
Normalmente vamos a trabajar con `data.frames` así que no necesitamos aprender todos los tipos que hay. Pero, si se encuentra un problema raro, o un mensaje de error que no se ha visto antes, siempre es buena idea revisar qué clase (`class` y `mode`) de objetos son.

Por ejemplo, un `data.frame` es un tipo de listado (`list`), verdad?
```{r mode_seedln}
mode(suiza)                                                   
```
Que si, un `data.frame` no es otra cosa que un listado de columnas del mismo tamaño.

Cuál es el tamaño de este `data.frame`?
```{r length_seedln}
length(suiza)                                                 
```
Ahah, cuando preguntamos por longitud, recibimos un valor pequeí±a que parece como el número de columnas. Podemos verificarlo por preguntar directamente cuantas columnas hay...
```{r ncol_seedln}
ncol(suiza)                                                  
```
Bingo! Guardamos esta información en la mente.

Así que, si queremos verificar que todas las filasestén presentes, podemos preguntar por la longitud, preguntamos directamente por el número de las filas. Cuantas hay?
```{r nrow_seedln}
nrow(suiza) 
```
No tantas, el programa puede tratar conjuntos hasta centenares de miles de filas, pero se tomará su tiempo.

Podemos preguntar por las columnas y filas a la vez con `dim`, que devuelve las dimensiones de un conjunto o matriz.
```{r dim_seedln}
dim(suiza)
```
Resulta en las mismas respuestas que salieron de `ncol` y `nrow`, respectivamente(ojalá).

Vamos a ver como el conjunto es ensamblado con `str` (estructura).
```{r str_seedln}
str(suiza)                                                    
```
Con RStudio se puede ver la misma información haciendo click en la flechita azul, inmediatamente a la izquierda del nombre del conjunto en la ventanilla del entorno.  Tambien se puede ver los nombres de las columnas, y su clase.


Estadísticos de resumen
--------------------------------------------------------------------------------
Dejamos los datos de Siuza y en su lugar vamos a jugar con unos datos acerca del potencial de hidratación de hojas. Empezamos por la lectura y luego revisarenmos el encambezado de todas las columnas con `head`.
```{r head_leaf, eval=FALSE}
rn_leafWaterPot <- read.csv('rn_leafWaterPot.csv')
head(rn_leafWaterPot)
```

Vamos a calcular unos estadísticos de resumen. Primero, calculamos el promedio (o la media) con `mean()`.
```{r mean_leaf}
mean(rn_leafWaterPot$leaf.w)
```
Muy facil, no?

También, podemos calcular la mediana con `median()`...
```{r median_leaf}
median(rn_leafWaterPot$leaf.w)
```

y luego algunos quantiles.
```{r quantile_leaf}
quantile(rn_leafWaterPot$leaf.w)
```

Por defecto, la función `quantile` nos devuelve los cuantiles de 0, 25, 50, 75 y 100% (pero podemos preguntar por otros cuantiles utilizando el argumento `probs`, por ejemplo:)
```{r quantile2_leaf}
quantile(rn_leafWaterPot$leaf.w, probs=c(0.025, 0.5, 0.975))
```

También podemos calcular la moda. Sin embargo, para R `mode` tiene otro significado así que utilizamos otro método.  
```{r mode_leaf}
mode(rn_leafWaterPot$leaf.w)
```
En cambio, para calcular la moda (el valor específico de más frequencia) de un vector, introducimos nuestra amigable función `table`, la cual nos indique la frequencia de cada valor unica. 

```{r table_leaf}
table(rn_leafWaterPot$leaf.w)
```
Bueno, sale desordenado, así que vamos a ordenarlo con `sort`.

```{r table_leaf2}
sort(table(rn_leafWaterPot$leaf.w))
```
Bien! Ahora podemos ver que el valor más comun (la moda) es 0.38, lo que aparece 6 veces en el conjuntode datos.

Nos gustaria además conocer algo sobre la variabildad de los datos. Por ejemplo, qué podemos decir sobre la desviación estándar?.
```{r sd_leaf}
sd(rn_leafWaterPot$leaf.w)
```
Si queremos calcular la precisión de nuestro estimador de la media poblacional, podemos calcular el error estándar. Seguramente seria simple si usamos una función abrevaida como 'se', verdad?

```{r se_leaf}
se(rn_leafWaterPot$leaf.w) 
```
Oh, esto es inesperado... 

Resulta que R no tiene niguna función propia para calcular el error estandar  del promedio. : - (

Functions
-----------------------------------------------------------------------------
No todo está perdido. Sabemos como calcular el error estándar, paso a paso...Solo necesitamos la desviación estándar y el tamaño de la muestra. Estamos bastante expertos en escribir código ahora, sin tanto problema deberíamos ser capaces de crear nuestras propias funciones que ejecutaran nuestra orden. Manos a la obra entonces.

```{r se_funct}
se <- function(x) {
  sigma <- sd(x)
	n <- length(x)
  sigma / sqrt(n)
	}
```
Hemos definido una función! 
Para utilizar la función 'se' se espera disponer de un vector numérico 'x'. Lo primero que hace 'se' es calcular la desviación estándar de 'x', almacenando el resultado en el objeto `sigma`. Luego calcula el tamaño de la muestra (número de elementos de `x`) y almacena esto en el objeto `n`. La línea final de la función utiliza estos objetos anteriores para calcular el error estándar; además por ser la última línea, este es además el valor que la función imprimirá. Es útil notar que los objetos `sigma` y `n` sólo existen temporalmente, y desaparecerán una vez que la función haya finalizado el trabajo.

Aplicamos ahora la función.
```{r se_ci_leaf}
se(rn_leafWaterPot$leaf.w)
```
Destacable, ahora que hemos definido la función `se`, ya no recibimos ese error.

Utilicemos nuestra función `se` para crear otras funciones incluos más útiles. Por ejemplo un intervalo de confianza para la media poblacional.

```{r ci95}
ci95 <- function(x) {
	lo <- mean(x) - (se(x) * 1.96)
	up <- mean(x) + (se(x) * 1.96)
	c(lo, up)
	}
```

```{r run_ci95}
ci95(rn_leafWaterPot$leaf.w)
```


Los gráficos
-----------------------------------------------------------------------------

Hacer un gráfico de una variable es facil. Solo necesitamos saber elegir cual tipo de gráfico queremos, e introducir el nombre del vector (la variable)

Por ejemplo, un `boxplot`.
```{r boxplot_leafWater}
boxplot(rn_leafWaterPot$leaf.w)
```

O un `hist`ograma, un gráfico muy sencillo que representa la frecuencia de los valores observados en nuestra variable.
```{r hist_leafWater}
hist(rn_leafWaterPot$lnPot)
```

Otro gráfico común para la exploración de las variables de un conjunto multi-dimensional es un matriz de <<scatterplots>>. Realizamos este con la función `pairs` (parejas). 
```{r splom_leafWater}
pairs(sc_FrogsCrk1_2[9:14], panel=panel.smooth)
```
En este ejemplo hemos especificado otro argumento `panel=panel.smooth`, el cual agrega la linea suave. Esta linea representa la relación alisada (y local) entre las dos variables.  Lleva mucha información, pero puede ser muy útil como resumen de las correlaciones crudas que tenemos en el conjunto. 

La función más general para realizar los gráficos se llama `plot` que en inglés es el verbo más común para lo que hacemos. Basta dar dos vectores y nos devuelve un scatterplot sencillo. ¿lo probamos?

Vamos a hacerlo con unos datos acera del tiempo de mi ciudad de Melbourne, Australia.
```{r read_melb_weath}
	melb_weath <- read.csv('melb_weath.csv')
```

Aquí tenemos el codigo para un scatterplot sencillo.
```{r plot_melb_weath}
plot(1:48, as.numeric(melb_weath[48:1, 2]))
```
Ahora vamos a ver como se cambia un gráfico a la medida, y al gusto. 

Pero, teniendo en cuenta que estos datos representan una serie de tiempo, quizás seria mejor que lo indiquemos con una linea?
```{r plot_melb_weath_l}
plot(1:48, as.numeric(melb_weath[48:1, 2]), type='l')
```

Tal vez unos rótulos para los ejes, porque los genericos que salen no nos sirven.
```{r plot_melb_weath_l2}
plot(1:48, as.numeric(melb_weath[48:1, 2]), type='l', xlab='la Hora', 
	ylab='Temperatura (Celsius)')
```

Aumentamos los limites del eje Y con el argumento `ylim=c()`, y cambiamos la orientación de los rótulos con `las=1`.  
```{r plot_melb_weath_l3}
plot(1:48, as.numeric(melb_weath[48:1, 2]), type='l', xlab='la Hora', 
	ylab='Temperatura (Celsius)', ylim=c(0, 50), las=1)
```